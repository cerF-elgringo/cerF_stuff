async function adjustBoardForWordLength() {
  const mi = document.getElementById('mobile-input'); 
  if(mi) mi.maxLength = wordLength;

  const wrapper = document.getElementById('game-wrapper'); 
  const container = document.getElementById('game-container'); 
  const gap = 10;
  const totalGapsH = (Math.max(1, wordLength) - 1) * gap;
  const totalGapsV = (6 - 1) * gap;

  if (!wrapper || wrapper.clientWidth < 20) {
    requestAnimationFrame(() => setTimeout(adjustBoardForWordLength, 40)); 
    return; 
  }

  try { 
    if(document.fonts && document.fonts.status !== 'loaded') {
      await document.fonts.ready; 
      await new Promise(r=>setTimeout(r,20)); 
    } 
  } catch(e){}

  const bodyStyle = getComputedStyle(document.body); 
  const bodyPadL = parseFloat(bodyStyle.paddingLeft||0); 
  const bodyPadR = parseFloat(bodyStyle.paddingRight||0);

  const measuredWrapperWidth = Math.max(160, wrapper.clientWidth || Math.floor(window.innerWidth*0.9)); 
  const viewportUsableWidth = Math.max(160, window.innerWidth - bodyPadL - bodyPadR - 32);
  const availableWidth = Math.min(measuredWrapperWidth, viewportUsableWidth);

  const titleEl = wrapper.querySelector('h1'); 
  const alphabetEl = document.getElementById('alphabet'); 
  const titleH = titleEl ? Math.ceil(titleEl.getBoundingClientRect().height) : 0; 
  const keyboardH = alphabetEl ? Math.ceil(alphabetEl.getBoundingClientRect().height) : 72;

  const verticalReserve = 40; 
  const usableHeight = Math.max(120, window.innerHeight - titleH - keyboardH - verticalReserve - (parseFloat(bodyStyle.paddingTop||0)+parseFloat(bodyStyle.paddingBottom||0)));

  const cellByWidth = Math.floor((availableWidth - totalGapsH) / Math.max(1, wordLength)); 
  const cellByHeight = Math.floor((usableHeight - totalGapsV) / 6);

  const ORIGINAL_CELL = 63; 
  const MIN_CELL = 12;

  // Pick the smallest so it fits both width and height
  let cellSize = Math.min(cellByWidth, cellByHeight, ORIGINAL_CELL); 
  if(cellSize < MIN_CELL) cellSize = MIN_CELL;

  // Extra safety: shrink if total board still exceeds viewport
  const totalBoardHeight = (cellSize * 6) + totalGapsV + titleH + keyboardH + verticalReserve;
  if(totalBoardHeight > window.innerHeight){
    const availableForCells = Math.max((window.innerHeight - titleH - keyboardH - verticalReserve - totalGapsV), MIN_CELL * 6); 
    const newCell = Math.floor(availableForCells / 6); 
    cellSize = Math.max(MIN_CELL, Math.min(cellSize, newCell)); 
  }

  const finalGridWidth = (cellSize * wordLength) + totalGapsH; 
  if(finalGridWidth > availableWidth){
    const shrinkCell = Math.floor((availableWidth - totalGapsH) / Math.max(1, wordLength)); 
    cellSize = Math.max(MIN_CELL, Math.min(cellSize, shrinkCell)); 
  }

  const fontSize = Math.min(36, Math.max(10, Math.floor(cellSize * 0.6)));

  container.style.overflowX='hidden'; 
  container.style.minWidth=''; 
  container.style.justifyContent='center';
  container.style.width = `${Math.min(finalGridWidth, availableWidth)}px`;
  container.style.gridTemplateRows = `repeat(6, ${cellSize}px)`;

  for(let r=0; r<6; r++){ 
    const row = document.getElementById(`row${r}`); 
    if(!row) continue; 
    row.style.gridTemplateColumns = `repeat(${wordLength}, ${cellSize}px)`; 
    row.style.height = `${cellSize}px`; 
    
    const existingCells = row.querySelectorAll('.cell');
    if(existingCells.length !== wordLength) {
      row.innerHTML='';
      createCells(row, r, cellSize, fontSize);
    } else {
      existingCells.forEach(cell => {
        cell.style.width = `${cellSize}px`;
        cell.style.height = `${cellSize}px`;
        cell.style.fontSize = `${fontSize}px`;
      });
    }
    row.style.justifyContent='center'; 
  }
  updateActiveCell();
}
