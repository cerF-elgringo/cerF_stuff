async function adjustBoardForWordLength(){
    const mi = document.getElementById('mobile-input');
    if(mi) mi.maxLength = wordLength;

    const wrapper = document.getElementById('game-wrapper');
    const container = document.getElementById('game-container');
    const gap = 10; // matches CSS grid-gap
    const totalGapsH = (Math.max(1, wordLength) - 1) * gap;
    const totalGapsV = (6 - 1) * gap; // vertical gaps between rows

    // If wrapper is hidden, retry shortly (measurements would be wrong)
    const wrapperStyle = wrapper ? getComputedStyle(wrapper) : null;
    if (!wrapper || wrapperStyle.display === 'none' || wrapper.clientWidth < 20) {
        requestAnimationFrame(() => setTimeout(adjustBoardForWordLength, 40));
        return;
    }

    // Wait for fonts to be ready (if supported) so title height is accurate
    try {
        if (document.fonts && document.fonts.status !== 'loaded') {
            await document.fonts.ready;
            await new Promise(res => setTimeout(res, 20));
        }
    } catch (e) {
        // ignore
    }

    // Respect body padding and viewport so we never exceed visible width
    const bodyStyle = getComputedStyle(document.body);
    const bodyPadL = parseFloat(bodyStyle.paddingLeft || 0);
    const bodyPadR = parseFloat(bodyStyle.paddingRight || 0);

    // Measured wrapper width (includes wrapper padding) and viewport usable width
    const measuredWrapperWidth = Math.max(160, wrapper.clientWidth || Math.floor(window.innerWidth * 0.9));
    const viewportUsableWidth = Math.max(160, window.innerWidth - bodyPadL - bodyPadR - 32); // 32px breathing room

    // Use the smaller width so the grid never exceeds the visible area
    const availableWidth = Math.min(measuredWrapperWidth, viewportUsableWidth);

    // Measure title + keyboard heights (accurate measured height)
    const titleEl = wrapper.querySelector('h1');
    const alphabetEl = document.getElementById('alphabet');
    const titleH = titleEl ? Math.ceil(titleEl.getBoundingClientRect().height) : 0;
    const keyboardH = alphabetEl ? Math.ceil(alphabetEl.getBoundingClientRect().height) : 72; // fallback

    // breathing room for margins and overlays
    const verticalReserve = 40; // px

    // usable height for the six rows: viewport minus body paddings, title, keyboard and reserve
    const usableHeight = Math.max(120, window.innerHeight - titleH - keyboardH - verticalReserve - (parseFloat(bodyStyle.paddingTop||0) + parseFloat(bodyStyle.paddingBottom||0)));

    // compute constraints
    const cellByWidth = Math.floor((availableWidth - totalGapsH) / Math.max(1, wordLength));
    const cellByHeight = Math.floor((usableHeight - totalGapsV) / 6);

    // limits: never bigger than original design, but allow small as last resort
    const ORIGINAL_CELL = 63;
    const MIN_CELL = 12;      // last-resort minimum to keep everything visible

    // choose smallest constraint so everything fits both horizontally and vertically
    let cellSize = Math.min(cellByWidth, cellByHeight, ORIGINAL_CELL);
    if (cellSize < MIN_CELL) cellSize = MIN_CELL;

    // final precaution: if computed layout is still taller than viewport (very small screens),
    // shrink further proportionally
    const totalBoardHeight = (cellSize * 6) + totalGapsV + titleH + keyboardH + verticalReserve;
    if (totalBoardHeight > window.innerHeight) {
        const availableForCells = Math.max((window.innerHeight - titleH - keyboardH - verticalReserve - totalGapsV), MIN_CELL * 6);
        const newCell = Math.floor(availableForCells / 6);
        cellSize = Math.max(MIN_CELL, Math.min(cellSize, newCell));
    }

    // Now compute final grid total width and ensure it fits the availableWidth
    const finalGridWidth = (cellSize * wordLength) + totalGapsH;
    if (finalGridWidth > availableWidth) {
        // shrink cells slightly to force fit (floor to integer)
        const shrinkCell = Math.floor((availableWidth - totalGapsH) / Math.max(1, wordLength));
        cellSize = Math.max(MIN_CELL, Math.min(cellSize, shrinkCell));
    }

    // font size: scale but do not exceed original
    const fontSize = Math.min(36, Math.max(10, Math.floor(cellSize * 0.6)));

    // ensure no forced internal scrollbars; center content
    container.style.overflowX = 'hidden';
    container.style.minWidth = '';
    container.style.justifyContent = 'center';

    // set container explicit width to the computed grid width so rows don't distribute oddly
    const gridTotalWidth = (cellSize * wordLength) + totalGapsH;
    container.style.width = `${Math.min(gridTotalWidth, availableWidth)}px`;

    // set container row heights so rows don't overlap vertically
    container.style.gridTemplateRows = `repeat(6, ${cellSize}px)`;

    // recreate cells for each row using the calculated sizes
    for(let r=0;r<6;r++){
        const row = document.getElementById(`row${r}`);
        if(!row) continue;
        row.style.gridTemplateColumns = `repeat(${wordLength}, ${cellSize}px)`;
        row.style.height = `${cellSize}px`;
        row.innerHTML = '';
        createCells(row, r, cellSize, fontSize);
        row.style.justifyContent = 'center';
    }

    updateActiveCell();
}
